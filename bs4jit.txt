Timer unit: 1e-06 s

Total time: 0.135765 s
File: <ipython-input-56-6ce7e132484d>
Function: best_splitting_feature_4jit at line 22

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    22                                           def best_splitting_feature_4jit(X, y, Nbins):
    23                                                   
    24         1            2      2.0      0.0      best_feature = None # Keep track of the best feature 
    25         1            1      1.0      0.0      best_threshold = None
    26         1            0      0.0      0.0      best_I = -1     # Keep track of the best info gain so far 
    27                                           
    28                                               #the number of data points in the parent node
    29         1            3      3.0      0.0      num_data_points = y.shape[0]
    30                                               
    31                                               #the entropy of the parent node
    32         1            1      1.0      0.0      Nparent = len(y)
    33         1          188    188.0      0.1      C,unique_counts = np.unique(y,return_counts=True) #the id of classes and number of each
    34         1            7      7.0      0.0      Pc = unique_counts/len(y)
    35         1           24     24.0      0.0      Hy = -(Pc*np.log(Pc)).sum()
    36                                               
    37                                               # Loop through each feature to consider splitting on that feature
    38        29           40      1.4      0.0      for feature in range(X.shape[1]):
    39                                                   
    40        28           61      2.2      0.0          fvals = X[:,feature]
    41        28          460     16.4      0.3          fvals = np.sort(fvals)  #sorting the values
    42        28           30      1.1      0.0          if num_data_points > Nbins:            
    43        28          230      8.2      0.2              fvals = fvals[range(0,num_data_points,Nbins)]
    44                                                   
    45                                                   #loop through all values of current feature to find the best split
    46       308          532      1.7      0.4          for threshold in fvals:
    47       280          756      2.7      0.6              yleft_ = np.empty(num_data_points) #temporary array
    48       280          232      0.8      0.2              numL = 0
    49       280          662      2.4      0.5              yright_ = np.empty(num_data_points)
    50       280          206      0.7      0.2              numR = 0
    51                                                       
    52                                                       #loop through all data points to perform the left and right split
    53     28280        22275      0.8     16.4              for p in range(num_data_points):
    54     28000        30038      1.1     22.1                  if X[p,feature] < threshold:
    55                                                               yleft_[numL] = y[p]
    56                                                               numL +=1
    57                                                           else:
    58     28000        30697      1.1     22.6                      yright_[numR] = y[p]
    59     28000        22335      0.8     16.5                      numR +=1       
    60                                                               
    61       280          590      2.1      0.4              yleft = yleft_[0:numL] #LEFT SPLIT
    62       280          329      1.2      0.2              yright = yright_[0:numR] #RIGHT SPLIT
    63       280          342      1.2      0.3              Nleft = len(yleft)
    64       280          227      0.8      0.2              Nright = len(yright)
    65                                           
    66                                                       #leftnode entropy
    67       280         4282     15.3      3.2              C,unique_counts = np.unique(yleft,return_counts=True) #the id of classes and number of each
    68       280         1658      5.9      1.2              Pc = unique_counts/len(yleft)
    69       280         2903     10.4      2.1              Hleft = -(Pc*np.log(Pc)).sum()
    70                                                       
    71       280        12189     43.5      9.0              C,unique_counts = np.unique(yright,return_counts=True) #the id of classes and number of each
    72       280         1019      3.6      0.8              Pc = unique_counts/len(yright)
    73       280         2538      9.1      1.9              Hright = -(Pc*np.log(Pc)).sum()
    74                                           
    75       280          624      2.2      0.5              I = Hy -( (Nleft/Nparent)*Hleft + (Nright/Nparent)*Hright )   
    76                                           
    77                                                       
    78                                                       # If this is the best error we have found so far, store the feature as best_feature
    79                                                       # the threshold as the best threshold and the error as best_error
    80       280          281      1.0      0.2              if I > best_I:
    81         1            1      1.0      0.0                  best_feature = feature
    82         1            1      1.0      0.0                  best_threshold = threshold
    83         1            0      0.0      0.0                  best_I = I
    84                                                   
    85         1            1      1.0      0.0      return best_feature, best_threshold # Return the best feature and threshold